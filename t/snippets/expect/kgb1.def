# a variety of line types for testing -kgb
use strict;
use Test;
use Encode qw(from_to encode decode
  encode_utf8 decode_utf8
  find_encoding is_utf8);
use charnames qw(greek);
our $targetdir = "/usr/local/doc/HTML/Perl";
local (
    $tocfile,   $loffile,   $lotfile,         $footfile,
    $citefile,  $idxfile,   $figure_captions, $table_captions,
    $footnotes, $citations, %font_size,       %index,
    %done,      $t_title,   $t_author,        $t_date,
    $t_address, $t_affil,   $changed
);
my @UNITCHECKs =
    B::unitcheck_av->isa("B::AV")
  ? B::unitcheck_av->ARRAY
  : ();
my @CHECKs = B::check_av->isa("B::AV") ? B::check_av->ARRAY : ();
my $dna    = Bio::LiveSeq::DNA->new( -seq => $dnasequence );
my $min    = 1;
my $max    = length($dnasequence);
my $T      = $G->_strongly_connected;
my %R      = $T->vertex_roots;
my @C;    # We're not calling the strongly_connected_components()
          # Do not separate this hanging side comment from previous
my $G    = shift;
my $exon = Bio::LiveSeq::Exon->new(
    -seq    => $dna,
    -start  => $min,
    -end    => $max,
    -strand => 1
);
my $octal_mode;
my @inputs = (
    0777, 0700, 0470, 0407, 0433, 0400, 0430, 0403, 0111, 0100,
    0110, 0101, 0731, 0713, 0317, 0371, 0173, 0137
);
my $impulse =
  ( 1 - $factor ) * ( 170 - $u ) + ( 350 / $u**0.65 + 500 / $u**5 ) * $factor;
my $r = q{
pm_to_blib: $(TO_INST_PM)
};
my $regcomp_re =
  "(?<routine>ckWARN(?:\\d+)?reg\\w*|vWARN\\d+|$regcomp_fail_re)";
my $position = List::MoreUtils::firstidx {
    refaddr $_ == $key
}
my @exons      = ($exon);
my $fastafile2 = "/tmp/tmpfastafile2";
my $grepcut    = 'egrep -v "[[:digit:]]|^ *$|sequences" | cut -c8-';  # grep/cut
my $alignprogram =
"/usr/local/etc/bioinfo/fasta2/align -s /usr/local/etc/bioinfo/fasta2/idnaa.mat $fastafile1 $fastafile2 2>/dev/null | $grepcut"
  ;                                                                   # ALIGN
my $xml      = new Mioga::XML::Simple( forcearray => 1 );
my $xml_tree = $xml->XMLin($skel_file);
my $skel_name =
  ( exists( $xml_tree->{'name'} ) ) ? $xml_tree->{'name'} : "";
my $grp = GroupGetValues( $conf->{dbh}, $group_id );
my $adm_profile =
  ProfileGetUser( $conf->{dbh}, $grp->{id_admin}, $group_id );
my $harness = TAP::Harness->new(
    { verbosity => 1, formatter_class => "TAP::Formatter::Console" } );
require File::Temp;
require Time::HiRes;
my ( $fh, $filename ) = File::Temp::tempfile("Time-HiRes-utime-XXXXXXXXX");
use File::Basename qw[dirname];
my $dirname     = dirname($filename);
my $CUT         = qr/\n=cut.*$EOP/;
my $pod_or_DATA = qr/
              ^=(?:head[1-4]|item) .*? $CUT
            | ^=pod .*? $CUT
            | ^=for .*? $CUT
            | ^=begin .*? $CUT
            | ^__(DATA|END)__\r?\n.*
            /smx;
require Cwd;
( my $boot = $self->{NAME} ) =~ s/:/_/g;
doit(
    sub { @E::ISA = qw/F/ },
    sub { @E::ISA = qw/D/;   @C::ISA = qw/F/ },
    sub { @C::ISA = qw//;    @A::ISA = qw/K/ },
    sub { @A::ISA = qw//;    @J::ISA = qw/F K/ },
    sub { @J::ISA = qw/F/;   @H::ISA = qw/K G/ },
    sub { @H::ISA = qw/G/;   @B::ISA = qw/B/ },
    sub { @B::ISA = qw//;    @K::ISA = qw/K J I/ },
    sub { @K::ISA = qw/J I/; @D::ISA = qw/A H B C/ },
);
my %extractor_for = (
    quotelike => [ $ws, $variable,    $id, { MATCH => \&extract_quotelike } ],
    regex     => [ $ws, $pod_or_DATA, $id, $exql ],
    string    => [ $ws, $pod_or_DATA, $id, $exql ],
    code      => [
        $ws, { DONT_MATCH => $pod_or_DATA },
        $variable, $id, { DONT_MATCH => \&extract_quotelike }
    ],
    code_no_comments => [
        { DONT_MATCH => $comment },
        $ncws, { DONT_MATCH => $pod_or_DATA },
        $variable, $id, { DONT_MATCH => \&extract_quotelike }
    ],
    executable             => [ $ws, { DONT_MATCH => $pod_or_DATA } ],
    executable_no_comments =>
      [ { DONT_MATCH => $comment }, $ncws, { DONT_MATCH => $pod_or_DATA } ],
    all => [ { MATCH => qr/(?s:.*)/ } ],
);
exit 1;
